# 多种排序算法实现与性能测试
本项目旨在实现并测试多种经典排序算法，包括冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、堆排序和桶排序。通过对不同规模数据的排序操作，对比各算法的正确性和运行效率。

## 一、项目结构
- `main.c`：主程序文件，负责生成测试数据、调用排序算法进行测试，并输出测试结果。
- `sorts.c`：包含各种排序算法的具体实现代码。
- `sorts.h`：声明了`sorts.c`中定义的排序函数，供`main.c`及其他可能的文件使用。

## 二、运行环境
- **操作系统**：理论上支持各种主流操作系统，如Windows、Linux、macOS等。本项目在Windows系统下开发和测试。
- **编译器**：建议使用GCC或Clang等C语言编译器。在Windows环境下，可通过MinGW或MSYS2获取GCC编译器；在Linux和macOS系统中，通常默认已安装或可通过包管理器轻松安装。

## 三、使用方法
1. **克隆项目**：在本地终端中执行`git clone <项目仓库地址>`，将项目代码克隆到本地。
2. **编译项目**：进入项目目录，使用命令`gcc -o sorts main.c sorts.c -Wall -Werror`进行编译。`-Wall`和`-Werror`选项用于开启更多编译警告并将警告视为错误，以提高代码质量。
3. **运行程序**：编译成功后，在命令行中输入`./sorts`（Windows系统下为`sorts.exe`）运行程序。程序会生成不同规模（100、1000、10000、100000、1000000）的随机数组，并对每个规模的数据应用各种排序算法进行排序，输出各算法的正确性和运行耗时（单位：微秒）。

## 四、代码说明
1. **排序算法实现**
    - **冒泡排序（`bubbleSort`）**：通过多次比较相邻元素并交换位置，将最大（或最小）元素逐步“冒泡”到数组末尾。
    - **选择排序（`selectionSort`）**：每次从未排序部分选择最小（或最大）元素，与未排序部分的第一个元素交换位置。
    - **插入排序（`insertionSort`）**：将数组分为已排序和未排序两部分，逐步将未排序元素插入到已排序部分的正确位置。
    - **快速排序（`quickSort`）**：采用分治思想，选择一个基准元素，将数组分为两部分，使得左边部分元素小于基准，右边部分元素大于基准，然后递归地对左右两部分进行排序。
    - **归并排序（`mergeSort`）**：同样基于分治策略，将数组不断二分，直到子数组长度为1，然后将有序子数组合并成一个完整的有序数组。本项目使用迭代版归并排序以避免栈溢出问题。
    - **希尔排序（`shellSort`）**：对插入排序的改进，通过将原始数据分成多个子序列，每个子序列的元素间隔较大，然后逐步缩小间隔进行插入排序，使得元素能更快地移动到合适位置。
    - **计数排序（`countingSort`）**：适用于数据范围较小的情况。通过统计每个元素出现的次数，再根据统计结果生成有序数组，是一种线性时间复杂度的排序算法。
    - **堆排序（`heapSort`）**：利用堆这种数据结构进行排序。先将数组构建成最大堆（或最小堆），然后依次取出堆顶元素并调整堆结构，最终得到有序数组。
    - **桶排序（`bucketSort`）**：假设数据服从均匀分布，将数据分到不同的桶中，再对每个桶内的数据进行排序，最后按顺序合并桶中的数据。
2. **测试框架**
    - `getCurrentTime`函数用于获取当前时间（微秒级），精确测量排序算法的运行时间。
    - `isSorted`函数用于验证排序后的数组是否有序，确保算法的正确性。
    - `generateRandomArray`函数生成指定规模和数值范围（0到10000）的随机数组，作为排序算法的输入数据。
    - `copyArray`函数用于复制数组，以便在不改变原始数据的情况下对副本进行排序测试。
    - `testSort`和`testSortWithArgs`函数分别用于测试普通排序算法和需要额外参数的排序算法（如桶排序），并输出算法名称、正确性和运行耗时。

## 五、性能分析
1. 一般情况下，对于小规模数据（如100、1000），时间复杂度为O(n²)的冒泡排序、选择排序和插入排序可能表现出较好的性能，因为其常数项较小。但随着数据规模增大（如100000、1000000），这些算法的运行时间会急剧增加。
2. 时间复杂度为O(n log n)的快速排序、归并排序、希尔排序和堆排序在处理大规模数据时具有明显优势，运行时间增长相对缓慢。其中，快速排序平均性能最优，但在最坏情况下（如数据已有序）时间复杂度会退化到O(n²)；归并排序是稳定排序算法，性能稳定；希尔排序通过增量序列改进了插入排序的性能；堆排序则利用堆结构实现高效排序。
3. 计数排序和桶排序在数据范围有限且分布均匀的情况下，时间复杂度可达到O(n)，性能非常高效。但这两种算法对数据有一定要求，计数排序依赖于数据的范围，桶排序依赖于数据的分布。

## 六、贡献指南
1. 欢迎对项目感兴趣的开发者参与贡献。如果你发现了代码中的问题，如错误、性能瓶颈等，或者有新的功能想法，如添加新的排序算法、优化现有算法等，请先在项目仓库中创建一个issue，描述问题或功能需求。
2. 如果你想提交代码修改，请先fork本项目仓库到自己的账号下，在本地进行修改并测试通过后，提交一个pull request。在pull request中详细说明修改的内容和目的，等待项目维护者审核和合并。

## 七、许可证
本项目采用[MIT许可证](LICENSE)，允许自由使用、修改和分发，但需保留版权声明和许可证文件。 